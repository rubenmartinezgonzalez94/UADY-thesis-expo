[//]: # (# Avances de tesis.)


# Introducción

<!--
Buen dia, les habla ing Ruben mg y a continuación les presentaré
los avances en mi investigacion titulada "Estimación ...".
asesorada por los doctores Arturo E
-->

<!--
La presentación estara estructurada con una introducción del problema que se aborda
la metodología que se propone
y otros conceptos del marco teorico como objetivos, preguntas, hipotesis.
-->
::: {.notes}
- Haciendo introducción al tema, podemos debatir algunas cuesitones sobre el estacionamiento como:
:::

## Estacionamiento

:::: {.columns}
::: {.column width="40%"}

- Importancia
- Problemas
- Soluciones

:::

::: {.column width="60%"}
<img src="/img/estfull.png" alt=""/>
:::
::::


::: {.notes}

- Su importancia ya permite a los conductores dejar sus vehículos de forma segura en estos espacios
mientras realizan otras actividades.

- y cual es el problema con esto , pues En lugares concurridos, puede ser complicado encontrar un lugar
  o incluso si ya encontraste un lugar, la maniobra para posicionar el vehículo dentro del espacio
  se puede entorpecer por obstaculos o falta de visibilidad o inexperiencia del conductor.
  o incluso conductores habilidosos pueden fallar cuando es necesario una serie de maniobras
  que dependen unas de otras y si calculas mal en alguna ,
  en la siguiente maniobra se tendria rectificar esta equivocación.

- que ayuda a solucionar este problema , pues Con la ayuda de sistemas de asistencia al conductor.

:::

## Sistemas de asistencia al conductor

<img src="/img/asistencia1.jpg" alt=""/>
<img src="/img/reversa.jpeg" alt="" />
<img src="/img/reversa2.jpg" alt=""/>

::: {.notes}

- Los sistemas de asistencia al conductor son programas informáticos
  que proporcionan información sobre el entorno del vehículo.

- Algunos son tan avanzados que pueden estacionar el vehículo de forma autónoma
  y otros más simples que solo proporcionan información
  sobre la distancia a objetos cercanos y orientacion del vehículo.

- Una solución que puede contribuir a la mejora de estos sistemas es la inteligencia artificial.
  Si una IA aprendiera a estacionar un vehículo en un ambiente controlado,
  con este conocimiento podría retornar información de utilidad para cumplir esta tarea.

:::

## Aprendizaje por Refuerzo

::: {.incremental}
:::: {.columns}

::: {.column width="50%"}
<img class="my-rl-diagram" src="/img/RL.svg" alt="" />
:::

::: {.column width="25%"}

- Agente  <img class="my-rl-list" src="/img/tesla.png" alt="" />
- Acciones <img class="my-rl-list" src="/img/actions.png" alt="" />
- Entorno <img class="my-rl-list" src="/img/park.png" alt="" />
:::

::: {.column width="25%"}

- Interprete <img class="my-rl-list" src="/img/cam.jpg" alt="" />
- Estado <img class="my-rl-list" src="/img/ubi.png" alt="" />
- Recompensa
  <img class="my-rl-list-s" src="/img/sum.png" alt=""/>
  <img class="my-rl-list-s" src="/img/bien.png" alt=""/>
  <img class="my-rl-list-s" src="/img/mas.png" alt=""/>
  <img class="my-rl-list-s" src="/img/mal.png" alt=""/>
:::

::::
:::

::: {.notes}

- Dentro de la inteligencia artificial, un buen candidato para esta situación
  son los algoritmos de aprendizaje por refuerzo.

- Estos algoritmos se basan en la interacción de un agente con un entorno.
  El agente realiza acciones en el entorno que pueden ser interpretadas y evaluadas
  según va cambiando el estado del entorno.
  estos cambios en el entorno pueden ser evaluados con una recompensa que el agente
  utiliza para aprender a elegir acciones cada vez mejores.


- En el caso de estacionamiento, el agente sería el vehículo,
  las acciones serían las maniobras que puede realizar el vehículo, acelerar, frenar, girar.
  El entorno sería el estacionamiento.
  El intérprete sería un sistema que analice los datos de los sensores del vehículo, como la cámara.
  El estado podría ser la pose del vehículo con respecto al estacionamiento.
  La recompensa podría ser una función que evalue que tan bien esta este estado.

- pero... ¿Qué haría falta para implementar un algoritmo así?
  Pues el agente, las acciones y el entorno nos lo puede proveer un simulador.
  Y el intérprete para obtener el estado y que tanmbien esta este estado lo podemos implementar
  con un sistema de visión computacional.
:::

## Visión Computacional

<img class="my-h" src="/img/line_detection/lines.png" alt=""/>
<img class="my-h" src="/img/line_detection/lines_only.png" alt=""/>
<img class="my-h" src="/img/line_detection/povs.png" alt=""/>
<img class="my-h" src="/img/front.png" alt=""/>
<img class="my-h" src="/img/up.png" alt=""/>

:::footer
:::

::: {.notes}
- y en construir este sistema de vision computacional sera nuesto objetivo en esta investigacion.

- donde podemos procesar los datos de la camara
  y representar la posicion del vehículo con respecto al estacionamiento.

- Para representar esta posición el mayor desafio es detectar los cajones de estacionamiento
 a partir de las imagenes capturadas por la camara del vehiculo ya que el poder ubicar los cajones
  de estacionamientoes fundamental en cualquier tarea de planeacion de movimiento


[//]: # (  y para demostrar su aplicacion práctica, junto a la simulacion lo probaremos en algoritmos de aprendizaje por)

[//]: # (  refuerzo.)
:::

# Marco Teórico
::: {.notes}
por lo que podemos definir el marco teorico de la investigacion como:
:::
## Hipótesis

“Estimando la posición relativa al estacionamiento de un vehículo mediante cámaras y sensores,
y utilizando esta posición, se puede lograr un sistema de estacionamiento automático en simulación.”

## Objetivo general

Desarrollar un sistema de estimación de la posición relativa al estacionamiento de un vehículo
mediante cámaras y sensores para estacionamiento automático

## Preguntas de investigación

- ¿Cómo se puede representar la posición de un vehículo con respecto a su espacio de estacionamiento?
- ¿Cómo se puede estimar esta posición utilizando las cámaras y sensores del vehículo?
- ¿Cómo usar esta posición estimada para que el vehículo se estacione automáticamente?

# Metodología

::: {.notes}
como parte de la metodología a seguir, necesitamos un entorno de simulación que nos permita modelar
esta situación lo mas realista posible.
:::

## Entorno de simulación

### Carla

:::: {.columns}

::: {.column width="50%"}
<iframe src="https://www.youtube.com/embed/q4V9GYjA1pE?autoplay=1&mute=1&start=0&end=55&loop=1&playlist=q4V9GYjA1pE" width="100%" height="500"></iframe>
:::

::: {.column width="50%"}

- Código abierto [@dosovitskiy2017carla]
- Entornos urbanos
- Ciudades, carreteras, estacionamientos
- Vehículos, peatones, semáforos, sensores
- Api Python

- <img class="my-list-s" src="/img/intel.png" alt=""/>
<img class="my-list-s" src="/img/tri.png" alt=""/>
<img class="my-list-s" src="/img/compvisioncenter.png" alt=""/>
<img class="my-list-s" src="/img/UnrealEngine.svg" alt=""/>
:::

::::

:::footer
:::

::: {.notes}

Proponemos: Carla (Car learning to act) pssei.

- Un simulador de código abierto para la investigación de la conducción autónoma.
- Incluye mapas de entornos urbanos con ciudades, carreteras, estacionamientos,
- así como diversos actores como vehículos, peatones, semáforos o sensores
- que proveen interfaces para manipular su comportamiento a conveniencia.

:::

### Diseño del entorno de simulación

<img class="my-h" src="/img/distances.png" alt=""/>
<img class="my-h" src="/img/distances2.png" alt=""/>
<img class="my-h" src="/img/mirrow_camara_ex.jpg" alt=""/>
<img class="my-h" src="/img/mirrow_camara_ex2.jpg" alt=""/>

::: {.notes}

- para recrear el entorno se simulara un estacionamiento
  y un vehiculo equipado con camaras y sensores con el objetivo de estacionarse

- las imagenes de arriba son ejemplos la simulacion
- y las imagenes de abajo son ejemplos de los datos capturados por la camara
:::

## Detección del estacionamiento


::: {.notes}
una vez que tengamos los datos de la camara captados en el entorno de sumulacion
podemos procesarlos para detectar la ubicacion estacionamiento
:::
### Propiedades

- Los estacionamientos suelen formar estructuras regulares,
organizada como una retícula de paralelogramos.
- Las líneas de los paralelogramos al proyectarse en la cámara pueden
intersectarse en los “puntos de fuga”.

::: {.notes}
Hay dos propiedades que podemos aprovechar para plantear el mé-
todo:
:::

### Proyección de la imagen en el plano de la cámara
<img class="my-h" src="/img/line_detection/paralel_lines.png" alt=""/>
<img class="my-h" src="/img/line_detection/pov.png" alt=""/>

::: {.notes}
Y estos puntos de fuga son una propiedad muy interesante ya que
Cuando proyectamos un escenario del mundo real en 3 dimensiones como un estacionamiento a un plano
de 2 dimensiones como el sensor de una camara, se produce una transformacion en la imagen. Esta transformacion
provoca que las líneas paralelas en el mundo real, al proyectarse en el plano de la camara, se interseten en
un punto de fuga.
:::

### Geometría del estacionamiento

<img  src="/img/line_detection/pov_reticule.png" alt=""/>

::: {.notes}
Dado que las líneas de los cajones de estacionamiento son paralelas por su geometría, se forman patrones en
una retícula de paralelogramos. esta reticula esta definida por los puntos de fuga.
:::

### Geometría del estacionamiento
<img  src="/img/line_detection/pov_reticule_layer.png" alt=""/>

::: {.notes}
Esto permite utilizar tecnicas de deteccion de líneas para identificar los
puntos de fuga y estimar la posicion de la retícula de estacionamiento.
:::

### Geometría del estacionamiento

<iframe src="https://www.geogebra.org/classic/kczwvjn3?embed" width="100%" height="600" allowfullscreen style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0"></iframe>

::: {.notes}
ya que conociendo la ubicacion de los puntos de fuga y las equaciones de las líneas
podriamos calcular la ubicacion de cualquier punto de interes en la reticula.
:::

### Detección de líneas paralelas

:::: {.columns}

::: {.column width="50%"}
<img src="/img/line_detection/lines.png" alt=""/>
:::

::: {.column width="50%"}

- Umbralización
- Detección de contornos (Algoritmo de Canny)
- Lineas paralelas (Transformada de Hough)
:::
::::

::: {.notes}
Para detectar las líneas paralelas de interes en la imagen, primero se hace un 
preprocesamiento del area debajo del horizonte de la imagen donde estara el estacionamiento.
donde se resaltan las lineas claras mediante umbralizacion

luego se utiliza el algorithmo de Canny para detectar los bordes de las figuras resaltadas en la umbraizacion.

y sobre estos contornos encontrados se aplica la transformada de Hough para detectar coordenadas de inicio y fin
de las líneas resultantes

:::

### Ecuaciones de las rectas de las líneas

:::: {.columns}
::: {.column width="60%"}
$a x + b y + c = 0$
$$
\begin{aligned}
\left[\begin{array}{ccc}
x_1 & y_1 & 1 \\
x_2 & y_2 & 1
\end{array}\right]
\begin{bmatrix}
a \\
b \\
c
\end{bmatrix}
=
\begin{bmatrix}
0 \\
0
\end{bmatrix}
\end{aligned}
$$
:::
::: {.column width="40%"}

- Calculamos el espacio nulo (a,b,c) de cada recta
- SVD (Descomposición en valores singulares)

:::
::::

::: {.notes}
Una vez obtenidas las coordenadas de inicio y fin de cada línea paralela, podemos utilizar la ecuacion
general de la recta ax+by+c=0 ,para formular un sistema de ecuaciones de esta forma matricial
donde x1,y1 y x2,y2 son las coordenadas de inicio y fin de cada recta 
y abc son los coeficientes que podemos resolver con la descomposicion en valores singulares.

:::

### Ubicación de puntos de fuga

:::: {.columns}
::: {.column width="60%"}
<img src="/img/line_detection/Intersecciones_6.png" alt=""/>
:::
::: {.column width="40%"}
- Intersección de las rectas
- $P= l_1 \times l_2$
- Detección de cúmulos de puntos 
:::
::::

::: {.notes}
Dado que ya se tendrian las ecuaciones de todas las líneas en el plano de la camara, se
pueden calcular las intersecciones de estas líneas realizando un producto cruz entre las ecuaciones
homogeneas [A,B,C] de todos los pares de líneas

y evidentemente, la mayor cantidad de intersecciones se encontraran en los puntos de fuga principales
y para determinarlos se realizan tecnicas de AgglomerativeClustering 
:::

[//]: # (### Predicción de distancias)
[//]: # (Predicción de distancias)

### Intersección de n líneas
La intersección de n líneas homogéneas esta dado por
el eigen vector asociado al eigen valor más pequeño de la matriz $M$ donde:
$$
M = \sum_{i=1}^{n} w_i l_i l_i^T
$$
donde $w_i$ es un peso asociado a la linea $l_i$ .

<span style="font-size:0.6em">
Geometric Computation for Machine Vision 
[@kanatani1993geometric]
</span>

:::footer
:::

### Lineas que concurren en los puntos de fuga

:::: {.columns}

::: {.column width="50%"}
<img src="/img/line_detection/2vp.png" alt=""/>
:::

::: {.column width="50%"}
<img src="/img/line_detection/lineasFinales.png" alt=""/>
:::
::::

### Experimentación y ajuste de parámetros
<iframe src="https://www.youtube.com/embed/wckOQT7v0VI?autoplay=1&mute=1&loop=1&playlist=wckOQT7v0VI" width="100%" height="500">
</iframe>


## Ajuste de la retícula (RANSAC)

:::: {.columns}

::: {.column width="40%"}
<img src="/img/line_detection/ransac.png" alt=""/>
:::

::: {.column width="60%"}
- RANdom SAmple Consensus
- Es un algoritmo iterativo utilizado para ajustar modelos a datos con muchos valores atípicos (outliers)
:::
::::

## Ajuste de la retícula

:::: {.columns}

::: {.column width="50%"}
<img src="/img/line_detection/transformacion.png" alt=""/>
:::

::: {.column width="50%"}
<img src="/img/line_detection/tenasf_reticule.png" alt=""/>
:::
::::

## mediciones en la retícula

:::: {.columns}

::: {.column width="50%"}
<img src="/img/line_detection/distances.png" alt=""/>
:::

::: {.column width="50%"}

- 
  $$
  \mathbf{p}_1 = [x_1, y_1, 1]^T  ,
  \mathbf{p}_2 = [x_2, y_2, 1]^T 
  $$
- 
$$
\mathbf{P}_1 = \mathbf{H} \cdot \mathbf{p}_1,\quad
\mathbf{P}_2 = \mathbf{H} \cdot \mathbf{p}_2
$$

- 
$$
d = \sqrt{(X_2 - X_1)^2 + (Y_2 - Y_1)^2}
$$

:::
::::
::: {.notes}
- Teniendo la matriz de homografía $H$ que mapea el plano de la cámara al espacio del estacionamiento:
- Sean dos puntos en la imagen: 
- Convertimos los puntos de imagen a coordenadas reales en el plano: 
- Calculamos la distancia euclidiana en el espacio:
- Esto permite medir **distancias reales** usando solo la imagen y la homografía.
:::

## Posición relativa

<iframe src="https://www.geogebra.org/classic/a8pwjzyk?embed" width="100%" height="600" allowfullscreen style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0"></iframe>

<!-- 
$(\rho_1, \theta_1, z)$ , $(\rho_2, \theta_2, z)$ , $(\rho_3, \theta_3, z)$ , $(\rho_4, \theta_4, z)$
-->
:::footer
:::

::: {.notes}
para esto utilizaremos 4 vectores de distancias $\rho$ desde la camara a las 4 esquinas de uno 
de los cajones de estacionamiento ubicados en la reticula.
y 4 angulos $\theta$ que serian los angulos de orientacion entre los vectores de distancias y el eje de la camara.
y de esta forma tendriamos 4 vectores de coordenadas polares que junto a la altura conocida de la camara z
serian coordenadas cilindricas que representan la posicion del vehiculo con respecto al cajon de estacionamiento.

y estos vectores de coordenadas seran los que usaremos como modelo del estado del sistema.
:::


# Aplicación en ambiente de RL
## Gymnasium 

- Provee un API para crear y compartir entornos de aprendizaje por refuerzo [@gym].
- Permite evaluar agentes en diversos entornos estandarizados.
- El núcleo de Gym es Env, una clase de Python de alto nivel representando los procesos de decisión de Markov (MDP)
- La clase proporciona a los usuarios la capacidad de generar un estado inicial, realizar la transición a nuevos estados dada una acción y observar el entorno.

:::footer
:::

## Stable-baselines 3
- Implementaciones confiables de algoritmos de aprendizaje por refuerzo en PyTorch. [@baselines3]
- API de Gymnasium para interactuar con los entornos.
- Interfaz sencilla para entrenar y evaluar agentes de RL.
- Admite algoritmos populares como 
  - DQN (DeepQ-Network)
  - PPO (Proximal Policy Optimization)
  - SAC (Soft Actor-Critic)
  - A2C (Advantage Actor-Critic)

:::footer
:::

## Highway-env
- Colección de entornos para tareas de conducción autónoma y toma de decisiones tácticas [@highway-env]
<img class="my-h" src="/img/rl/parking-env.gif" alt=""/>
<img class="my-h" src="/img/rl/intersection-env.gif" alt=""/>
<img class="my-h" src="/img/rl/racetrack-env.gif" alt=""/>
<img class="my-h" src="/img/rl/roundabout-env.gif" alt=""/>

:::footer
:::

## Parking-env

- **Acciones**: espacio continuo  
  `Box([-1, -1], [1, 1]) → [aceleración, dirección]`
- **Observación**: vector continuo de 6 elementos:  
  `[x, y, vx, vy, cos(θ), sin(θ)]`  
- **Objetivo**: alcanzar una posición objetivo (`Landmark`) con orientación deseada.
- **Recompensa**: basada en la distancia al objetivo y penalizaciones por colisiones y acciones:
$$
  r = -|g - s| - α·|a|
$$

::: {.notes}
g: posición del goal (desired_goal)
s: estado actual (achieved_goal)
a: acción tomada
α: regularizador factor de penalización a acciones extremas
:::

:::footer
:::

## Parking-env (Nuestra versión)


:::: {.columns}

::: {.column width="70%"}
<iframe src="https://www.youtube.com/embed/B-4LIVjxhZ0?autoplay=1&mute=1&loop=1&playlist=B-4LIVjxhZ0" width="100%" height="500"></iframe>
:::

::: {.column width="30%"}

- Initialization Wrapper
- Observation Wrapper
- Action Wrapper
:::
:::: 



# Avances y Planificación

| **Actividad**                               | Ene | Feb | Mar | Abr | May | Jun | Jul | Ago | Sep | Oct | Nov | Dic | Ene | Feb | Mar | Abr | May | Jun |
|---------------------------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| Investigación y revisión bibliográfica      | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  |     |     |     |     |     |     |     |
| Diseño y Configuración del Entorno Simulado | ✅  | ✅  | ✅  | ✅  | ✅  |     |     |     |     |     |     |     |     |     |     |     |     |     |
| Adquisición y pre-procesamiento de Datos    |     |     |     |     | ✅  | ✅  | ✅  | ✅  |     |     |     |     |     |     |     |     |     |     |
| Interpretar los datos de los sensores       |     |     |     |     |     |     | ✅  | ✅  | ✅  |     |     |     |     |     |     |     |     |     |
| Obtención de mediciones en la imagen        |     |     |     |     |     |     |     |     | ✅  | ✅  |     |     |     |     |     |     |     |     |
| Detección de lineas y puntos de fuga        |     |     |     |     |     |     |     |     |     | ✅  | ✅  | ✅  |     |     |     |     |     |     |
| Estimación de la posición de la retícula    |     |     |     |     |     |     |     |     |     |     |     | ✅  | ✅  | ✅  |     |     |     |     |
| Establecer los límites de la retícula       |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |  ⏳ | 
| Estimación de distancias                    |     |     |     |     |     |     |     |     |     |     |     |     |     |     | ✅  | ✅  |     |     |
| Estimación de la posición relativa          |     |     |     |     |     |     |     |     |     |     |     |     |     |     | ✅  | ✅  |     |     |
| Utilizar la posición en algoritmos de RL    |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     | ✅  | ✅  | ⏳  |
| Documentación y Análisis de Resultados      | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅ | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ⏳  |
| Redacción y Revisión del documento de tesis |     |     |     |     |     |     |     |     |     |     |     | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ⏳  |  

# Fin
Gracias por su atención...

# Extras

## Recomendaciones
- Utilizar patrones de retículas mas complejas
- Fusionar información de la retícula de cada frame para construir un mapa con memoria de frames pasados
- Detectar estacionamientos ocupados para exluirlos de la retícula

## Propiedades de la representación homogénea de lineas y puntos
:::: {.columns}
::: {.column width="50%"}
si $l_1$ y $l_2$ son la representación homogénea de dos lineas en el plano
el punto donde se intersectan esta dado por:
$$
P = l_1 \times l_2
$$
:::
::: {.column width="50%"}
si $p_1$ y $p_2$ son la representación homogénea de dos puntos en el plano
la linea que pasa por estos puntos esta dado por:
$$
l = p_1 \times p_2
$$
:::
::::

Hartley, R., & Zisserman, A. (2003). Multiple view geometry in computer vision. Cambridge university press.

:::footer
:::


## Objetivos específicos:

- Modelar un ambiente de simulación de un vehículo y estacionamiento.
- Obtener datos de los sensores del vehículo en simulación.
- Interpretar los datos de los sensores mediante técnicas de visión computacional.
- Procesar los datos y estimar la posición del vehículo con respecto al estacionamiento.
- Utilizar la posición estimada para lograr un sistema de parqueo automático en simulación.

## Trabajos relacionados

| **Características / Trabajos relacionados**         | **Propia** | **Autonomous Driving Architectures** [@bachute2021autonomous] | **Vision-based Autonomous Car Racing** [@cai2021vision] | **Model-based Probabilistic Collision Detection** [@althoff2009model] | **Cost-effective Vehicle Detection System** [@alam2022cost] |
|-----------------------------------------------------|------------|---------------------------------------------------------------|---------------------------------------------------------|-----------------------------------------------------------------------|-------------------------------------------------------------|
| Utilización de cámaras RGB y sensores               | X          | X                                                             | X                                                       | X                                                                     | X                                                           |
| Algoritmos de Aprendizaje Automático                | X          | X                                                             | X                                                       | X                                                                     | X                                                           |
| Modelar la pose del vehiculo en el estacionamiento  | X          |                                                               |                                                         |                                                                       |                                                             |
| Maniobras de estacionamiento                        |            | X                                                             |                                                         |                                                                       |                                                             |
| Análisis de tareas en la conducción autónoma        |            | X                                                             |                                                         | X                                                                     |                                                             |
| Detección de vehículos en conducción autónoma       | X          |                                                               |                                                         |                                                                       | X                                                           |
| Predicción estocástica de ocupación de la carretera |            |                                                               |                                                         | X                                                                     |                                                             |
| Aprendizaje por refuerzo imitativo                  |            |                                                               | X                                                       |                                                                       |                                                             |

::: {.notes}

- Se han revisado trabajos relacionados con este contexto donde se utilizan camaras y sensores
  para resolver el problema de la conducción autónoma como el estacionamiento.

- Pero esto no es precisamente lo que queremos proponer en este trabajo.
  Queremos proponer un sistema de visión computacional que permita modelar la posición del vehículo
  con respecto al estacionamiento y utilizar este modelo para delegar la solución del estacionamiento
  a un algoritmo de aprendizaje automático.
:::

## Referencias

::: {#refs}
:::