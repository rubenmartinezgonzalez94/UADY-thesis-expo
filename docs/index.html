<!DOCTYPE html>
<html lang="en"><head>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/tabby.min.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.7.31">

  <title>Estimación de la pose de un vehículo respecto a su estacionamiento en simulación</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="site_libs/revealjs/dist/theme/quarto-0c8acc74dca0c2faaedea4940f202713.css">
  <link rel="stylesheet" href="styles.css">
  <link href="site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
</head>
<body class="quarto-dark">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Estimación de la pose de un vehículo respecto a su estacionamiento en simulación</h1>
  <p class="subtitle">Proyecto de tesis</p>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Rubén Martínez González 
</div>
<div class="quarto-title-author-email">
<a href="mailto:rubenmartinezgonzalez94@gmail.com">rubenmartinezgonzalez94@gmail.com</a>
</div>
        <p class="quarto-title-affiliation">
            Autor
          </p>
    </div>
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Dr.&nbsp;Arturo Espinosa Romero 
</div>
<div class="quarto-title-author-email">
<a href="mailto:eromero@correo.uady.mx">eromero@correo.uady.mx</a>
</div>
        <p class="quarto-title-affiliation">
            Asesor
          </p>
    </div>
</div>

  <p class="date">Jun, 2025</p>
</section>
<section>
<section id="introducción" class="title-slide slide level1 center">
<h1>Introducción</h1>
<!--
Buen dia, les habla ing Ruben mg y a continuación les presentaré
los avances en mi investigacion titulada "Estimación ...".
asesorada por los doctores Arturo E
-->
<!--
La presentación estara estructurada con una introducción del problema que se aborda
la metodología que se propone
y otros conceptos del marco teorico como objetivos, preguntas, hipotesis.
-->
<aside class="notes">
<ul>
<li>Haciendo introducción al tema, podemos debatir algunas cuesitones sobre el estacionamiento como:</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="estacionamiento" class="title-slide slide level2 center">
<h2>Estacionamiento</h2>
<div class="columns">
<div class="column" style="width:40%;">
<ul>
<li>Importancia</li>
<li>Problemas</li>
<li>Soluciones</li>
</ul>
</div><div class="column" style="width:60%;">
<p><img src="./img/estfull.png" alt=""></p>
</div></div>
<aside class="notes">
<ul>
<li><p>Su importancia ya permite a los conductores dejar sus vehículos de forma segura en estos espacios mientras realizan otras actividades.</p></li>
<li><p>y cual es el problema con esto , pues En lugares concurridos, puede ser complicado encontrar un lugar o incluso si ya encontraste un lugar, la maniobra para posicionar el vehículo dentro del espacio se puede entorpecer por obstaculos o falta de visibilidad o inexperiencia del conductor. o incluso conductores habilidosos pueden fallar cuando es necesario una serie de maniobras que dependen unas de otras y si calculas mal en alguna , en la siguiente maniobra se tendria rectificar esta equivocación.</p></li>
<li><p>que ayuda a solucionar este problema , pues Con la ayuda de sistemas de asistencia al conductor.</p></li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="sistemas-de-asistencia-al-conductor" class="title-slide slide level2 center">
<h2>Sistemas de asistencia al conductor</h2>
<p><img src="./img/asistencia1.jpg" alt=""> <img src="./img/reversa.jpeg" alt=""> <img src="./img/reversa2.jpg" alt=""></p>
<aside class="notes">
<ul>
<li><p>Los sistemas de asistencia al conductor son programas informáticos que proporcionan información sobre el entorno del vehículo.</p></li>
<li><p>Algunos son tan avanzados que pueden estacionar el vehículo de forma autónoma y otros más simples que solo proporcionan información sobre la distancia a objetos cercanos y orientacion del vehículo.</p></li>
<li><p>Una solución que puede contribuir a la mejora de estos sistemas es la inteligencia artificial. Si una IA aprendiera a estacionar un vehículo en un ambiente controlado, con este conocimiento podría retornar información de utilidad para cumplir esta tarea.</p></li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="aprendizaje-por-refuerzo" class="title-slide slide level2 center">
<h2>Aprendizaje por Refuerzo</h2>
<div class="columns">
<div class="column" style="width:50%;">
<p><img class="my-rl-diagram" src="./img/RL.svg" alt=""></p>
</div><div class="column" style="width:25%;">
<ul>
<li class="fragment">Agente <img class="my-rl-list" src="./img/tesla.png" alt=""></li>
<li class="fragment">Acciones <img class="my-rl-list" src="./img/actions.png" alt=""></li>
<li class="fragment">Entorno <img class="my-rl-list" src="./img/park.png" alt=""></li>
</ul>
</div><div class="column" style="width:25%;">
<ul>
<li class="fragment">Interprete <img class="my-rl-list" src="./img/cam.jpg" alt=""></li>
<li class="fragment">Estado <img class="my-rl-list" src="./img/ubi.png" alt=""></li>
<li class="fragment">Recompensa <img class="my-rl-list-s" src="./img/sum.png" alt=""> <img class="my-rl-list-s" src="./img/bien.png" alt=""> <img class="my-rl-list-s" src="./img/mas.png" alt=""> <img class="my-rl-list-s" src="./img/mal.png" alt=""></li>
</ul>
</div></div>
<aside class="notes">
<ul>
<li><p>Dentro de la inteligencia artificial, un buen candidato para esta situación son los algoritmos de aprendizaje por refuerzo.</p></li>
<li><p>Estos algoritmos se basan en la interacción de un agente con un entorno. El agente realiza acciones en el entorno que pueden ser interpretadas y evaluadas según va cambiando el estado del entorno. estos cambios en el entorno pueden ser evaluados con una recompensa que el agente utiliza para aprender a elegir acciones cada vez mejores.</p></li>
<li><p>En el caso de estacionamiento, el agente sería el vehículo, las acciones serían las maniobras que puede realizar el vehículo, acelerar, frenar, girar. El entorno sería el estacionamiento. El intérprete sería un sistema que analice los datos de los sensores del vehículo, como la cámara. El estado podría ser la pose del vehículo con respecto al estacionamiento. La recompensa podría ser una función que evalue que tan bien esta este estado.</p></li>
<li><p>pero… ¿Qué haría falta para implementar un algoritmo así? Pues el agente, las acciones y el entorno nos lo puede proveer un simulador. Y el intérprete para obtener el estado y que tanmbien esta este estado lo podemos implementar con un sistema de visión computacional.</p></li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="visión-computacional" class="title-slide slide level2 center">
<h2>Visión Computacional</h2>
<p><img class="my-h" src="./img/line_detection/lines.png" alt=""> <img class="my-h" src="./img/line_detection/lines_only.png" alt=""> <img class="my-h" src="./img/line_detection/povs.png" alt=""> <img class="my-h" src="./img/front.png" alt=""> <img class="my-h" src="./img/up.png" alt=""></p>
<div class="footer">

</div>
<aside class="notes">
<ul>
<li><p>y en construir este sistema de vision computacional sera nuesto objetivo en esta investigacion.</p></li>
<li><p>donde podemos procesar los datos de la camara y representar la posicion del vehículo con respecto al estacionamiento.</p></li>
<li><p>Para representar esta posición el mayor desafio es detectar los cajones de estacionamiento a partir de las imagenes capturadas por la camara del vehiculo ya que el poder ubicar los cajones de estacionamientoes fundamental en cualquier tarea de planeacion de movimiento</p></li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
</section>
<section>
<section id="marco-teórico" class="title-slide slide level1 center">
<h1>Marco Teórico</h1>
<aside class="notes">
<p>por lo que podemos definir el marco teorico de la investigacion como:</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="hipótesis" class="title-slide slide level2 center">
<h2>Hipótesis</h2>
<p>“Estimando la posición relativa al estacionamiento de un vehículo mediante cámaras y sensores, y utilizando esta posición, se puede lograr un sistema de estacionamiento automático en simulación.”</p>
</section>

<section id="objetivo-general" class="title-slide slide level2 center">
<h2>Objetivo general</h2>
<p>Desarrollar un sistema de estimación de la posición relativa al estacionamiento de un vehículo mediante cámaras y sensores para estacionamiento automático</p>
</section>

<section id="preguntas-de-investigación" class="title-slide slide level2 center">
<h2>Preguntas de investigación</h2>
<ul>
<li>¿Cómo se puede representar la posición de un vehículo con respecto a su espacio de estacionamiento?</li>
<li>¿Cómo se puede estimar esta posición utilizando las cámaras y sensores del vehículo?</li>
<li>¿Cómo usar esta posición estimada para que el vehículo se estacione automáticamente?</li>
</ul>
</section>
</section>
<section>
<section id="metodología" class="title-slide slide level1 center">
<h1>Metodología</h1>
<aside class="notes">
<p>como parte de la metodología a seguir, necesitamos un entorno de simulación que nos permita modelar esta situación lo mas realista posible.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="entorno-de-simulación" class="title-slide slide level2 center">
<h2>Entorno de simulación</h2>

</section>
<section id="carla" class="slide level3 center">
<h3>Carla</h3>
<div class="columns">
<div class="column" style="width:50%;">
<iframe src="https://www.youtube.com/embed/q4V9GYjA1pE?autoplay=1&amp;mute=1&amp;start=0&amp;end=55&amp;loop=1&amp;playlist=q4V9GYjA1pE" width="100%" height="500">
</iframe>
</div><div class="column" style="width:50%;">
<ul>
<li><p>Código abierto <span class="citation" data-cites="dosovitskiy2017carla">(<a href="#/referencias" role="doc-biblioref" onclick="">Dosovitskiy et al. 2017</a>)</span></p></li>
<li><p>Entornos urbanos</p></li>
<li><p>Ciudades, carreteras, estacionamientos</p></li>
<li><p>Vehículos, peatones, semáforos, sensores</p></li>
<li><p>Api Python</p></li>
<li><p><img class="my-list-s" src="./img/intel.png" alt=""> <img class="my-list-s" src="./img/tri.png" alt=""> <img class="my-list-s" src="./img/compvisioncenter.png" alt=""> <img class="my-list-s" src="./img/UnrealEngine.svg" alt=""></p></li>
</ul>
</div></div>
<div class="footer">

</div>
<aside class="notes">
<p>Proponemos: Carla (Car learning to act) pssei.</p>
<ul>
<li>Un simulador de código abierto para la investigación de la conducción autónoma.</li>
<li>Incluye mapas de entornos urbanos con ciudades, carreteras, estacionamientos,</li>
<li>así como diversos actores como vehículos, peatones, semáforos o sensores</li>
<li>que proveen interfaces para manipular su comportamiento a conveniencia.</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="diseño-del-entorno-de-simulación" class="slide level3 center">
<h3>Diseño del entorno de simulación</h3>
<p><img class="my-h" src="./img/distances.png" alt=""> <img class="my-h" src="./img/distances2.png" alt=""> <img class="my-h" src="./img/mirrow_camara_ex.jpg" alt=""> <img class="my-h" src="./img/mirrow_camara_ex2.jpg" alt=""></p>
<aside class="notes">
<ul>
<li><p>para recrear el entorno se simulara un estacionamiento y un vehiculo equipado con camaras y sensores con el objetivo de estacionarse</p></li>
<li><p>las imagenes de arriba son ejemplos la simulacion</p></li>
<li><p>y las imagenes de abajo son ejemplos de los datos capturados por la camara</p></li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="detección-del-estacionamiento" class="title-slide slide level2 center">
<h2>Detección del estacionamiento</h2>
<aside class="notes">
<p>una vez que tengamos los datos de la camara captados en el entorno de sumulacion podemos procesarlos para detectar la ubicacion estacionamiento</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="propiedades" class="slide level3 center">
<h3>Propiedades</h3>
<ul>
<li>Los estacionamientos suelen formar estructuras regulares, organizada como una retícula de paralelogramos.</li>
<li>Las líneas de los paralelogramos al proyectarse en la cámara pueden intersectarse en los “puntos de fuga”.</li>
</ul>
<aside class="notes">
<p>Hay dos propiedades que podemos aprovechar para plantear el mé- todo:</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="proyección-de-la-imagen-en-el-plano-de-la-cámara" class="slide level3 center">
<h3>Proyección de la imagen en el plano de la cámara</h3>
<p><img class="my-h" src="./img/line_detection/paralel_lines.png" alt=""> <img class="my-h" src="./img/line_detection/pov.png" alt=""></p>
<aside class="notes">
<p>Y estos puntos de fuga son una propiedad muy interesante ya que Cuando proyectamos un escenario del mundo real en 3 dimensiones como un estacionamiento a un plano de 2 dimensiones como el sensor de una camara, se produce una transformacion en la imagen. Esta transformacion provoca que las líneas paralelas en el mundo real, al proyectarse en el plano de la camara, se interseten en un punto de fuga.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="geometría-del-estacionamiento" class="slide level3 center">
<h3>Geometría del estacionamiento</h3>

<img src="./img/line_detection/pov_reticule.png" alt="" class="r-stretch"><aside class="notes">
<p>Dado que las líneas de los cajones de estacionamiento son paralelas por su geometría, se forman patrones en una retícula de paralelogramos. esta reticula esta definida por los puntos de fuga.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="geometría-del-estacionamiento-1" class="slide level3 center">
<h3>Geometría del estacionamiento</h3>

<img src="./img/line_detection/pov_reticule_layer.png" alt="" class="r-stretch"><aside class="notes">
<p>Esto permite utilizar tecnicas de deteccion de líneas para identificar los puntos de fuga y estimar la posicion de la retícula de estacionamiento.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="geometría-del-estacionamiento-2" class="slide level3 center">
<h3>Geometría del estacionamiento</h3>
<iframe src="https://www.geogebra.org/classic/kczwvjn3?embed" width="100%" height="600" allowfullscreen="" style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0">
</iframe>
<aside class="notes">
<p>ya que conociendo la ubicacion de los puntos de fuga y las equaciones de las líneas podriamos calcular la ubicacion de cualquier punto de interes en la reticula.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="detección-de-líneas-paralelas" class="slide level3 center">
<h3>Detección de líneas paralelas</h3>
<div class="columns">
<div class="column" style="width:50%;">
<p><img src="./img/line_detection/lines.png" alt=""></p>
</div><div class="column" style="width:50%;">
<ul>
<li>Umbralización</li>
<li>Detección de contornos (Algoritmo de Canny)</li>
<li>Lineas paralelas (Transformada de Hough)</li>
</ul>
</div></div>
<aside class="notes">
<p>Para detectar las líneas paralelas de interes en la imagen, primero se hace un preprocesamiento del area debajo del horizonte de la imagen donde estara el estacionamiento. donde se resaltan las lineas claras mediante umbralizacion</p>
<p>luego se utiliza el algorithmo de Canny para detectar los bordes de las figuras resaltadas en la umbraizacion.</p>
<p>y sobre estos contornos encontrados se aplica la transformada de Hough para detectar coordenadas de inicio y fin de las líneas resultantes</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="ecuaciones-de-las-rectas-de-las-líneas" class="slide level3 center">
<h3>Ecuaciones de las rectas de las líneas</h3>
<div class="columns">
<div class="column" style="width:60%;">
<p><span class="math inline">\(a x + b y + c = 0\)</span> <span class="math display">\[
\begin{aligned}
\left[\begin{array}{ccc}
x_1 &amp; y_1 &amp; 1 \\
x_2 &amp; y_2 &amp; 1
\end{array}\right]
\begin{bmatrix}
a \\
b \\
c
\end{bmatrix}
=
\begin{bmatrix}
0 \\
0
\end{bmatrix}
\end{aligned}
\]</span></p>
</div><div class="column" style="width:40%;">
<ul>
<li>Calculamos el espacio nulo (a,b,c) de cada recta</li>
<li>SVD (Descomposición en valores singulares)</li>
</ul>
</div></div>
<aside class="notes">
<p>Una vez obtenidas las coordenadas de inicio y fin de cada línea paralela, podemos utilizar la ecuacion general de la recta ax+by+c=0 ,para formular un sistema de ecuaciones de esta forma matricial donde x1,y1 y x2,y2 son las coordenadas de inicio y fin de cada recta y abc son los coeficientes que podemos resolver con la descomposicion en valores singulares.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="ubicación-de-puntos-de-fuga" class="slide level3 center">
<h3>Ubicación de puntos de fuga</h3>
<div class="columns">
<div class="column" style="width:60%;">
<p><img src="./img/line_detection/Intersecciones_6.png" alt=""></p>
</div><div class="column" style="width:40%;">
<ul>
<li>Intersección de las rectas</li>
<li><span class="math inline">\(P= l_1 \times l_2\)</span></li>
<li>Detección de cúmulos de puntos</li>
</ul>
</div></div>
<aside class="notes">
<p>Dado que ya se tendrian las ecuaciones de todas las líneas en el plano de la camara, podemos calcular todas las interscciones de cada par de líneas realizando el producto cruz entre las ecuaciones homogéneas de cada par de líneas.</p>
<p>y de las intersecciones oresultantes, podemos filtrar todas las que no esten cerca del horizonte de la imagen ya que conocemos que la camara del vehiculo esta orientada paralela al suelo hacia el horizonte</p>
<p>y la mayor cantidad de estas intersecciones cercanas al horizonte, se aglomeraran en una zona cercana a los puntos de fuga y podemos determinar estas zonas usando algoritmos de agrupamiento de cumulos de puntos, espesificamente utilizamos AgglomerativeClustering de sklearn</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="intersección-de-n-líneas" class="slide level3 center">
<h3>Intersección de n líneas</h3>
<p>La intersección de n líneas homogéneas esta dado por el eigen vector asociado al eigen valor más pequeño de la matriz <span class="math inline">\(M\)</span> donde: <span class="math display">\[
M = \sum_{i=1}^{n} w_i l_i l_i^T
\]</span> donde <span class="math inline">\(w_i\)</span> es una ponderación asociado a la linea <span class="math inline">\(l_i\)</span> .</p>
<p><span style="font-size:0.6em"> Geometric Computation for Machine Vision <span class="citation" data-cites="kanatani1993geometric">(<a href="#/referencias" role="doc-biblioref" onclick="">Kanatani 1993</a>)</span> </span></p>
<aside class="notes">
<p>teniendo identificadas estos cumulos de intersecciones donde sabemos que estan los puntos de fuga, para saber la ubicacion del punto de fuga que mejor representa estas intersecciones,</p>
<p>podemos calcular el eigen vector asociado al eigen valor mas pequeño de la matriz M donde M es la suma de cada linea homogenea por su transpuesta y multiplicada por una ponderacion que calculamos en dependencia de la longitud de cada linea</p>
<p>w - ponderacion</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
<div class="footer">

</div>
</section>
<section id="lineas-que-concurren-en-los-puntos-de-fuga" class="slide level3 center">
<h3>Lineas que concurren en los puntos de fuga</h3>
<div class="columns">
<div class="column" style="width:50%;">
<p><img src="./img/line_detection/2vp.png" alt=""></p>
</div><div class="column" style="width:50%;">
<p><img src="./img/line_detection/lineasFinales.png" alt=""></p>
</div><aside class="notes">
<ul>
<li>y realizando esta operacion ya tendriamos la ubicacion de los puntos de fuga de la imagen</li>
<li>y podemos filtrar las lineas relevantes que los generaron</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</div>
</section>
<section id="experimentación-y-ajuste-de-parámetros" class="slide level3 center">
<h3>Experimentación y ajuste de parámetros</h3>
<iframe src="https://www.youtube.com/embed/wckOQT7v0VI?autoplay=0&amp;mute=1&amp;loop=1&amp;playlist=wckOQT7v0VI" width="100%" height="500">
</iframe>
<aside class="notes">
<ul>
<li>debido a que es muy costoso en cuanto a hardweare tener el simulador abierto durante mucho tiempo,</li>
<li>grabamos secuencias de varias simulaciones y construimos una aplicacion en python</li>
<li>para hacer la experimentacion de estos metodos vision computacional procesando estas secuencias.</li>
<li>durante la ejecucion de la aplicacion se pueden ajustar los parametros de cada etapa del procesamiento, como los umbrales de canny, hough, clustering, cercania al horizonte, etc.</li>
<li>y se pueden ver los resultados de cada etapa del procesamiento en tiempo real presionando atajos de teclado.</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="ajuste-de-la-retícula-ransac" class="title-slide slide level2 center">
<h2>Ajuste de la retícula (RANSAC)</h2>
<div class="columns">
<div class="column" style="width:40%;">
<p><img src="./img/line_detection/ransac.png" alt=""></p>
</div><aside class="notes">
<ul>
<li>entonces una vez que tenemos estas lineas relevantes que representan la reticula de estacionamiento,</li>
<li>podemos ajustar una reticula a estas lineas utilizando el algoritmo RANSAC</li>
<li>que es un algoritmo iterativo que ajusta un modelo a los datos con muchos valores atípicos .</li>
<li>este es un caso tipico donde se utiliza para encontrar cual es la linea que mejor representa una nube de puntos</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside><div class="column" style="width:60%;">
<ul>
<li>RANdom SAmple Consensus</li>
<li>Es un algoritmo iterativo utilizado para ajustar modelos a datos con muchos valores atípicos (outliers)</li>
</ul>
</div></div>
</section>

<section id="ajuste-de-la-retícula-ransac-1" class="title-slide slide level2 center">
<h2>Ajuste de la retícula (RANSAC)</h2>
<p><img src="./img/line_detection/ramsac_loop.svg" alt=""> <img src="./img/line_detection/transformacion.png" alt=""></p>
<aside class="notes">
<ul>
<li>en nuestro caso, utilizamos una variacion de RANSAC que ajusta el modelo una reticula de n x n a las lineas detectadas</li>
<li>para esto el algoritomo …</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
<div class="footer">

</div>
</section>

<section id="ajuste-de-la-retícula-ransac-2" class="title-slide slide level2 center">
<h2>Ajuste de la retícula (RANSAC)</h2>
<div class="columns">
<p><img src="./img/line_detection/tenasf_reticule.png" alt=""></p>
</div>
<aside class="notes">
<ul>
<li>y al final del algoritmo la homografia con menor error es una buena candidata para mapear la reticula regular a los cajones de estacionamiento.</li>
<li>en este ejempo se ve como los cajones mas cercanos a la camara se ajustaron bastante bien</li>
<li>tambien se ve como un efecto espejo arriba del horizonte de la imagen debido a un trabajo pendiente que aun queda por hacer y es acotar los limites de la reticula que proyectamos.</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="mediciones-en-la-retícula" class="title-slide slide level2 center">
<h2>mediciones en la retícula</h2>
<div class="columns">
<div class="column" style="width:50%;">
<p><img src="./img/line_detection/distances.png" alt=""></p>
</div><div class="column" style="width:50%;">
<ul>
<li><p><span class="math display">\[
\mathbf{p}_1 = [x_1, y_1, 1]^T  ,
\mathbf{p}_2 = [x_2, y_2, 1]^T
\]</span></p></li>
<li><p><span class="math display">\[
\mathbf{P}_1 = \mathbf{H} \cdot \mathbf{p}_1,\quad
\mathbf{P}_2 = \mathbf{H} \cdot \mathbf{p}_2
\]</span></p></li>
<li><p><span class="math display">\[
d = \sqrt{(X_2 - X_1)^2 + (Y_2 - Y_1)^2}
\]</span></p></li>
</ul>
</div></div>
<aside class="notes">
<ul>
<li>Teniendo la matriz de homografía <span class="math inline">\(H\)</span> que mapea el plano de la cámara al espacio del estacionamiento:</li>
<li>Sean dos puntos en la imagen:</li>
<li>Convertimos los puntos de imagen a coordenadas reales en el plano:</li>
<li>Calculamos la distancia euclidiana en el espacio:</li>
<li>Esto permite medir <strong>distancias reales</strong> usando solo la imagen y la homografía.</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="posición-relativa" class="title-slide slide level2 center">
<h2>Posición relativa</h2>
<iframe src="https://www.geogebra.org/classic/a8pwjzyk?embed" width="100%" height="600" allowfullscreen="" style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0">
</iframe>
<!-- 
$(\rho_1, \theta_1, z)$ , $(\rho_2, \theta_2, z)$ , $(\rho_3, \theta_3, z)$ , $(\rho_4, \theta_4, z)$
-->
<div class="footer">

</div>
<aside class="notes">
<p>para esto utilizaremos 4 vectores de distancias <span class="math inline">\(\rho\)</span> desde la camara a las 4 esquinas de uno de los cajones de estacionamiento ubicados en la reticula. y 4 angulos <span class="math inline">\(\theta\)</span> que serian los angulos de orientacion entre los vectores de distancias y el eje de la camara. y de esta forma tendriamos 4 vectores de coordenadas polares que junto a la altura conocida de la camara z serian coordenadas cilindricas que representan la posicion del vehiculo con respecto al cajon de estacionamiento.</p>
<p>y estos vectores de coordenadas seran los que usaremos como modelo del estado del sistema.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
</section>
<section>
<section id="aplicación-en-ambiente-de-rl" class="title-slide slide level1 center">
<h1>Aplicación en ambiente de RL</h1>
<aside class="notes">
<ul>
<li><p>y hasta aqui ya tendriamos cumplido el objetivo de la investigacion, que es poder representar la posicion del vehiculo con respecto al estacionamiento a partir de las imagenes de la camara.</p></li>
<li><p>pero para demostrar como se puede utilizar esta investigacion para entrenar un agente de aprendizaje por refuerzo hicimos una experimentacion extra de nuestro modelo en un ambiente de RL.</p></li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="highway-env" class="title-slide slide level2 center">
<h2>Highway-env</h2>
<ul>
<li>Colección de entornos para tareas de conducción autónoma y toma de decisiones tácticas <span class="citation" data-cites="highway-env">(<a href="#/referencias" role="doc-biblioref" onclick="">Leurent 2018</a>)</span> <img class="my-h" src="./img/rl/parking-env.gif" alt=""> <img class="my-h" src="./img/rl/intersection-env.gif" alt=""> <img class="my-h" src="./img/rl/racetrack-env.gif" alt=""> <img class="my-h" src="./img/rl/roundabout-env.gif" alt=""></li>
</ul>
<aside class="notes">
<ul>
<li>y para esto nos apoyamos en la librería highway-env que es una colección de entornos para tareas de conducción autónoma y toma de decisiones tácticas.</li>
<li>esta libreria disena sus environments utilizando la libreria gymnasium, muy popular para implementar entornos</li>
<li>y baseline3 para entrenar los agentes con implementaciones confiables de algoritmos de aprendizaje por refuerzo como deep Q-Network, Proximal Policy Optimization, Soft Actor-Critic, este último es el que utilizamos en nuestra experimentación.</li>
<li>aqui podemos ver algunos de los entornos que provee, rotondas, intersecciones, curvas, estacionamiento, etc.</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
<div class="footer">

</div>
</section>

<section id="parking-env" class="title-slide slide level2 center">
<h2>Parking-env</h2>
<ul>
<li><strong>Acciones</strong>: espacio continuo<br>
<code>Box([-1, -1], [1, 1]) → [aceleración, dirección]</code></li>
<li><strong>Observación</strong>: vector continuo de 6 elementos:<br>
<code>[x, y, vx, vy, cos(θ), sin(θ)]</code><br>
</li>
<li><strong>Objetivo</strong>: alcanzar una posición objetivo (<code>Landmark</code>) con orientación deseada.</li>
<li><strong>Recompensa</strong>: basada en la distancia al objetivo y penalizaciones por colisiones y acciones: <span class="math display">\[
r = -|g - s| - α·|a|
\]</span></li>
</ul>
<aside class="notes">
<p>este enviroment de estacionamiento se llama parking-env y es un entorno de estacionamiento</p>
<ul>
<li>g: posición del goal (desired_goal)</li>
<li>s: estado actual (achieved_goal)</li>
<li>a: acción tomada</li>
<li>α: regularizador factor de penalización a acciones extremas</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
<div class="footer">

</div>
</section>

<section id="parking-env-nuestra-versión" class="title-slide slide level2 center">
<h2>Parking-env (Nuestra versión)</h2>
<div class="columns">
<div class="column" style="width:70%;">
<iframe src="https://www.youtube.com/embed/B-4LIVjxhZ0?autoplay=1&amp;mute=1&amp;loop=1&amp;playlist=B-4LIVjxhZ0" width="100%" height="500">
</iframe>
</div><div class="column" style="width:30%;">
<ul>
<li>Initialization Wrapper</li>
<li>Observation Wrapper</li>
<li>Action Wrapper</li>
</ul>
</div></div>
</section>

<section id="entrenamiento-del-agente" class="title-slide slide level2 center">
<h2>Entrenamiento del agente</h2>
<div class="columns">
<div class="column" style="width:33.3%;">
<table class="caption-top">
<thead>
<tr class="header">
<th><strong>Initial</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ep_len_mean</td>
<td>87.5</td>
</tr>
<tr class="even">
<td>ep_rew_mean</td>
<td>-51.8</td>
</tr>
<tr class="odd">
<td>success_rate</td>
<td>0</td>
</tr>
<tr class="even">
<td><strong>time</strong></td>
<td></td>
</tr>
<tr class="odd">
<td>episodes</td>
<td>4</td>
</tr>
<tr class="even">
<td>fps</td>
<td>52</td>
</tr>
<tr class="odd">
<td>time_elapsed</td>
<td>6</td>
</tr>
<tr class="even">
<td>total_timesteps</td>
<td>350</td>
</tr>
<tr class="odd">
<td><strong>train</strong></td>
<td></td>
</tr>
<tr class="even">
<td>actor_loss</td>
<td>-2.41</td>
</tr>
<tr class="odd">
<td>critic_loss</td>
<td>0.0353</td>
</tr>
<tr class="even">
<td>ent_coef</td>
<td>0.78</td>
</tr>
<tr class="odd">
<td>ent_coef_loss</td>
<td>-0.832</td>
</tr>
<tr class="even">
<td>learning_rate</td>
<td>0.001</td>
</tr>
<tr class="odd">
<td>n_updates</td>
<td>249</td>
</tr>
</tbody>
</table>
</div><div class="column" style="width:33.3%;">
<table class="caption-top">
<thead>
<tr class="header">
<th><strong>Highway-env</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ep_len_mean</td>
<td>20.1</td>
</tr>
<tr class="even">
<td>ep_rew_mean</td>
<td>-6.92</td>
</tr>
<tr class="odd">
<td>success_rate</td>
<td>0.93</td>
</tr>
<tr class="even">
<td><strong>time</strong></td>
<td></td>
</tr>
<tr class="odd">
<td>episodes</td>
<td>3292</td>
</tr>
<tr class="even">
<td>fps</td>
<td>36</td>
</tr>
<tr class="odd">
<td>time_elapsed</td>
<td>2758</td>
</tr>
<tr class="even">
<td>total_timesteps</td>
<td>99957</td>
</tr>
<tr class="odd">
<td><strong>train</strong></td>
<td></td>
</tr>
<tr class="even">
<td>actor_loss</td>
<td>1.44</td>
</tr>
<tr class="odd">
<td>critic_loss</td>
<td>0.00482</td>
</tr>
<tr class="even">
<td>ent_coef</td>
<td>0.00608</td>
</tr>
<tr class="odd">
<td>ent_coef_loss</td>
<td>0.622</td>
</tr>
<tr class="even">
<td>learning_rate</td>
<td>0.001</td>
</tr>
<tr class="odd">
<td>n_updates</td>
<td>99856</td>
</tr>
</tbody>
</table>
</div><div class="column" style="width:33.3%;">
<table class="caption-top">
<thead>
<tr class="header">
<th><strong>Our Wrapper</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ep_len_mean</td>
<td>92</td>
</tr>
<tr class="even">
<td>ep_rew_mean</td>
<td>-35.2</td>
</tr>
<tr class="odd">
<td>success_rate</td>
<td>0.18</td>
</tr>
<tr class="even">
<td><strong>time</strong></td>
<td></td>
</tr>
<tr class="odd">
<td>episodes</td>
<td>101</td>
</tr>
<tr class="even">
<td>fps</td>
<td>12</td>
</tr>
<tr class="odd">
<td>time_elapsed</td>
<td>1520</td>
</tr>
<tr class="even">
<td>total_timesteps</td>
<td>9210</td>
</tr>
<tr class="odd">
<td><strong>train</strong></td>
<td></td>
</tr>
<tr class="even">
<td>actor_loss</td>
<td>-0.76</td>
</tr>
<tr class="odd">
<td>critic_loss</td>
<td>0.041</td>
</tr>
<tr class="even">
<td>ent_coef</td>
<td>0.62</td>
</tr>
<tr class="odd">
<td>ent_coef_loss</td>
<td>-0.34</td>
</tr>
<tr class="even">
<td>learning_rate</td>
<td>0.001</td>
</tr>
<tr class="odd">
<td>n_updates</td>
<td>8215</td>
</tr>
</tbody>
</table>
</div></div>
</section>
</section>
<section id="avances-y-planificación" class="title-slide slide level1 center">
<h1>Avances y Planificación</h1>
<table class="caption-top" style="width:100%;">
<colgroup>
<col style="width: 33%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Actividad</strong></th>
<th>Ene</th>
<th>Feb</th>
<th>Mar</th>
<th>Abr</th>
<th>May</th>
<th>Jun</th>
<th>Jul</th>
<th>Ago</th>
<th>Sep</th>
<th>Oct</th>
<th>Nov</th>
<th>Dic</th>
<th>Ene</th>
<th>Feb</th>
<th>Mar</th>
<th>Abr</th>
<th>May</th>
<th>Jun</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Investigación y revisión bibliográfica</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Diseño y Configuración del Entorno Simulado</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Adquisición y pre-procesamiento de Datos</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Interpretar los datos de los sensores</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Obtención de mediciones en la imagen</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Detección de lineas y puntos de fuga</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Estimación de la posición de la retícula</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Estimación de distancias</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Estimación de la posición relativa</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Establecer los límites de la retícula</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>⏳</td>
</tr>
<tr class="odd">
<td>Utilizar la posición en algoritmos de RL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>⏳</td>
</tr>
<tr class="even">
<td>Documentación y Análisis de Resultados</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>⏳</td>
</tr>
<tr class="odd">
<td>Redacción y Revisión del documento de tesis</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>⏳</td>
</tr>
</tbody>
</table>
</section>

<section id="fin" class="title-slide slide level1 center">
<h1>Fin</h1>
<p>Gracias por su atención…</p>
</section>

<section>
<section id="extras" class="title-slide slide level1 center">
<h1>Extras</h1>

</section>
<section id="recomendaciones" class="title-slide slide level2 center">
<h2>Recomendaciones</h2>
<ul>
<li>Utilizar patrones de retículas mas complejas</li>
<li>Fusionar información de la retícula de cada frame para construir un mapa con memoria de frames pasados</li>
<li>Detectar estacionamientos ocupados para exluirlos de la retícula</li>
</ul>
</section>

<section id="gymnasium" class="title-slide slide level2 center">
<h2>Gymnasium</h2>
<ul>
<li>Provee un API para crear y compartir entornos de aprendizaje por refuerzo <span class="citation" data-cites="gym">(<a href="#/referencias" role="doc-biblioref" onclick="">Towers et al. 2024</a>)</span>.</li>
<li>Permite evaluar agentes en diversos entornos estandarizados.</li>
<li>El núcleo de Gym es Env, una clase de Python de alto nivel representando los procesos de decisión de Markov (MDP)</li>
<li>La clase proporciona a los usuarios la capacidad de generar un estado inicial, realizar la transición a nuevos estados dada una acción y observar el entorno.</li>
</ul>
<div class="footer">

</div>
</section>

<section id="stable-baselines-3" class="title-slide slide level2 center">
<h2>Stable-baselines 3</h2>
<ul>
<li>Implementaciones confiables de algoritmos de aprendizaje por refuerzo en PyTorch. <span class="citation" data-cites="baselines3">(<a href="#/referencias" role="doc-biblioref" onclick="">Raffin et al. 2021</a>)</span></li>
<li>API de Gymnasium para interactuar con los entornos.</li>
<li>Interfaz sencilla para entrenar y evaluar agentes de RL.</li>
<li>Admite algoritmos populares como
<ul>
<li>DQN (DeepQ-Network)</li>
<li>PPO (Proximal Policy Optimization)</li>
<li>SAC (Soft Actor-Critic)</li>
<li>A2C (Advantage Actor-Critic)</li>
</ul></li>
</ul>
<div class="footer">

</div>
</section>

<section id="propiedades-de-la-representación-homogénea-de-lineas-y-puntos" class="title-slide slide level2 center">
<h2>Propiedades de la representación homogénea de lineas y puntos</h2>
<div class="columns">
<div class="column" style="width:50%;">
<p>si <span class="math inline">\(l_1\)</span> y <span class="math inline">\(l_2\)</span> son la representación homogénea de dos lineas en el plano el punto donde se intersectan esta dado por: <span class="math display">\[
P = l_1 \times l_2
\]</span></p>
</div><div class="column" style="width:50%;">
<p>si <span class="math inline">\(p_1\)</span> y <span class="math inline">\(p_2\)</span> son la representación homogénea de dos puntos en el plano la linea que pasa por estos puntos esta dado por: <span class="math display">\[
l = p_1 \times p_2
\]</span></p>
</div></div>
<p>Hartley, R., &amp; Zisserman, A. (2003). Multiple view geometry in computer vision. Cambridge university press.</p>
<div class="footer">

</div>
</section>

<section id="objetivos-específicos" class="title-slide slide level2 center">
<h2>Objetivos específicos:</h2>
<ul>
<li>Modelar un ambiente de simulación de un vehículo y estacionamiento.</li>
<li>Obtener datos de los sensores del vehículo en simulación.</li>
<li>Interpretar los datos de los sensores mediante técnicas de visión computacional.</li>
<li>Procesar los datos y estimar la posición del vehículo con respecto al estacionamiento.</li>
<li>Utilizar la posición estimada para lograr un sistema de parqueo automático en simulación.</li>
</ul>
</section>

<section id="trabajos-relacionados" class="title-slide slide level2 center">
<h2>Trabajos relacionados</h2>
<table class="caption-top">
<colgroup>
<col style="width: 16%">
<col style="width: 3%">
<col style="width: 19%">
<col style="width: 17%">
<col style="width: 22%">
<col style="width: 19%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Características / Trabajos relacionados</strong></th>
<th><strong>Propia</strong></th>
<th><strong>Autonomous Driving Architectures</strong> <span class="citation" data-cites="bachute2021autonomous">(<a href="#/referencias" role="doc-biblioref" onclick="">Bachute and Subhedar 2021</a>)</span></th>
<th><strong>Vision-based Autonomous Car Racing</strong> <span class="citation" data-cites="cai2021vision">(<a href="#/referencias" role="doc-biblioref" onclick="">Cai et al. 2021</a>)</span></th>
<th><strong>Model-based Probabilistic Collision Detection</strong> <span class="citation" data-cites="althoff2009model">(<a href="#/referencias" role="doc-biblioref" onclick="">Althoff, Stursberg, and Buss 2009</a>)</span></th>
<th><strong>Cost-effective Vehicle Detection System</strong> <span class="citation" data-cites="alam2022cost">(<a href="#/referencias" role="doc-biblioref" onclick="">Alam, Jaffery, and Sharma 2022</a>)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Utilización de cámaras RGB y sensores</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>Algoritmos de Aprendizaje Automático</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td>Modelar la pose del vehiculo en el estacionamiento</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Maniobras de estacionamiento</td>
<td></td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Análisis de tareas en la conducción autónoma</td>
<td></td>
<td>X</td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>Detección de vehículos en conducción autónoma</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr class="odd">
<td>Predicción estocástica de ocupación de la carretera</td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>Aprendizaje por refuerzo imitativo</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<aside class="notes">
<ul>
<li><p>Se han revisado trabajos relacionados con este contexto donde se utilizan camaras y sensores para resolver el problema de la conducción autónoma como el estacionamiento.</p></li>
<li><p>Pero esto no es precisamente lo que queremos proponer en este trabajo. Queremos proponer un sistema de visión computacional que permita modelar la posición del vehículo con respecto al estacionamiento y utilizar este modelo para delegar la solución del estacionamiento a un algoritmo de aprendizaje automático.</p></li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="referencias" class="title-slide slide level2 smaller scrollable">
<h2>Referencias</h2>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-alam2022cost" class="csl-entry" role="listitem">
Alam, Altaf, Zainul Abdin Jaffery, and Himanshu Sharma. 2022. <span>“A Cost-Effective Computer Vision-Based Vehicle Detection System.”</span> <em>Concurrent Engineering</em> 30 (2): 148–58. <a href="https://journals.sagepub.com/doi/abs/10.1177/1063293X211069193">https://journals.sagepub.com/doi/abs/10.1177/1063293X211069193</a>.
</div>
<div id="ref-althoff2009model" class="csl-entry" role="listitem">
Althoff, Matthias, Olaf Stursberg, and Martin Buss. 2009. <span>“Model-Based Probabilistic Collision Detection in Autonomous Driving.”</span> <em>IEEE Transactions on Intelligent Transportation Systems</em> 10 (2): 299–310. <a href="https://ieeexplore.ieee.org/abstract/document/4895669">https://ieeexplore.ieee.org/abstract/document/4895669</a>.
</div>
<div id="ref-bachute2021autonomous" class="csl-entry" role="listitem">
Bachute, Mrinal R, and Javed M Subhedar. 2021. <span>“Autonomous Driving Architectures: Insights of Machine Learning and Deep Learning Algorithms.”</span> <em>Machine Learning with Applications</em> 6: 100164. <a href="https://www.sciencedirect.com/science/article/pii/S2666827021000827">https://www.sciencedirect.com/science/article/pii/S2666827021000827</a>.
</div>
<div id="ref-cai2021vision" class="csl-entry" role="listitem">
Cai, Peide, Hengli Wang, Huaiyang Huang, Yuxuan Liu, and Ming Liu. 2021. <span>“Vision-Based Autonomous Car Racing Using Deep Imitative Reinforcement Learning.”</span> <em>IEEE Robotics and Automation Letters</em> 6 (4): 7262–69. <a href="https://ieeexplore.ieee.org/abstract/document/9488179">https://ieeexplore.ieee.org/abstract/document/9488179</a>.
</div>
<div id="ref-dosovitskiy2017carla" class="csl-entry" role="listitem">
Dosovitskiy, Alexey, German Ros, Felipe Codevilla, Antonio Lopez, and Vladlen Koltun. 2017. <span>“<span>CARLA</span>: <span>An</span> Open Urban Driving Simulator,”</span> 1–16. <a href="https://ieeexplore.ieee.org/abstract/document/9488179">https://ieeexplore.ieee.org/abstract/document/9488179</a>.
</div>
<div id="ref-kanatani1993geometric" class="csl-entry" role="listitem">
Kanatani, Kenichi. 1993. <em>Geometric Computation for Machine Vision</em>. Oxford university press.
</div>
<div id="ref-highway-env" class="csl-entry" role="listitem">
Leurent, Edouard. 2018. <span>“An Environment for Autonomous Driving Decision-Making.”</span> <em>GitHub Repository</em>. <a href="https://github.com/eleurent/highway-env" class="uri">https://github.com/eleurent/highway-env</a>; GitHub.
</div>
<div id="ref-baselines3" class="csl-entry" role="listitem">
Raffin, Antonin, Ashley Hill, Adam Gleave, Anssi Kanervisto, Maximilian Ernestus, and Noah Dormann. 2021. <span>“Stable-Baselines3: Reliable Reinforcement Learning Implementations.”</span> <em>Journal of Machine Learning Research</em> 22 (268): 1–8. <a href="http://jmlr.org/papers/v22/20-1364.html">http://jmlr.org/papers/v22/20-1364.html</a>.
</div>
<div id="ref-gym" class="csl-entry" role="listitem">
Towers, Mark, Ariel Kwiatkowski, Jordan Terry, John U. Balis, Gianluca De Cola, Tristan Deleu, Manuel Goulão, et al. 2024. <span>“Gymnasium: A Standard Interface for Reinforcement Learning Environments.”</span> <a href="https://arxiv.org/abs/2407.17032">https://arxiv.org/abs/2407.17032</a>.
</div>
</div>


</section>
</section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<p><img src="./img/uady.svg" class="slide-logo"></p>
<div class="footer footer-default">
<p>Facultad de Matemáticas<br>Universidad Autónoma de Yucatán</p>
</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="site_libs/revealjs/plugin/search/search.js"></script>
  <script src="site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="site_libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': false,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
            const codeEl = trigger.previousElementSibling.cloneNode(true);
            for (const childEl of codeEl.children) {
              if (isCodeAnnotation(childEl)) {
                childEl.remove();
              }
            }
            return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp('/' + window.location.host + '/');
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>